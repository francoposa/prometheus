// GENERATED CODE - DO NOT EDIT
// This file was generated by protoc-gen-fastmarshal

package writev2

import (
	"fmt"
	"math/bits"
	"sync"
	"sync/atomic"

	"github.com/CrowdStrike/csproto"
)

// ByteSlicePool is a synchronized pool of byte slices with support for arbitrary sizes.
type ByteSlicePool struct {
	pools []sync.Pool
}

// NewByteSlicePool creates a new ByteSlicePool.
func NewByteSlicePool() *ByteSlicePool {
	// Create a pool for each size class (up to 2^20 bytes, for example).
	// You can adjust the maximum size as needed.
	const maxSizeClass = 20 // 2^20 = 1MB
	pools := make([]sync.Pool, maxSizeClass+1)
	for i := range pools {
		size := 1 << i // Size class: 2^i
		pools[i].New = func() interface{} {
			return make([]byte, 0, size)
		}
	}
	return &ByteSlicePool{
		pools: pools,
	}
}

// Get returns a byte slice of at least the requested size.
// If a slice of the required size is available in the pool, it is returned.
// Otherwise, a new slice is allocated.
func (p *ByteSlicePool) Get(size int) []byte {
	if size <= 0 {
		return nil
	}

	// Find the appropriate size class for the requested size.
	sizeClass := p.sizeClass(size)

	// Get a slice from the pool.
	buf := p.pools[sizeClass].Get().([]byte)

	// Ensure the slice has enough capacity.
	if cap(buf) < size {
		// If the slice is too small, allocate a new one.
		buf = make([]byte, 0, size)
	}

	// Reset the slice length to 0.
	return buf[:size]
}

// Put returns a byte slice to the pool.
func (p *ByteSlicePool) Put(buf []byte) {
	if cap(buf) == 0 {
		return // Ignore empty slices.
	}

	// Determine the size class of the slice.
	sizeClass := p.sizeClass(cap(buf))

	// Reset the slice length to 0 before putting it back.
	buf = buf[:0]

	// Return the slice to the appropriate pool.
	p.pools[sizeClass].Put(buf)
}

// sizeClass returns the size class for a given size.
// The size class is the smallest power of 2 greater than or equal to the size.
func (p *ByteSlicePool) sizeClass(size int) int {
	if size <= 0 {
		return 0
	}
	// Calculate the next power of 2.
	nextPower := 1 << (bits.Len(uint(size - 1)))
	return bits.Len(uint(nextPower - 1))
}

var bufPool = NewByteSlicePool()

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for Request

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *Request) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	//if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
	//	return csz
	//}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Symbols (string,repeated)
	for _, sv := range m.Symbols {
		l = len(sv)
		sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Timeseries (message,repeated)
	for _, val := range m.Timeseries {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(5) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	//atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *Request) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := bufPool.Get(siz)
	defer bufPool.Put(buf)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *Request) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Symbols (4,string,repeated)
	for _, val := range m.Symbols {
		enc.EncodeString(4, val)
	}
	// Timeseries (5,message,repeated)
	for _, mm := range m.Timeseries {
		if err = enc.EncodeNested(5, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'timeseries' (tag=5): %w", err)
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *Request) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 4: // Symbols (string,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'symbols' (tag=4), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'symbols' (tag=4): %w", err)
			} else {
				m.Symbols = append(m.Symbols, s)
			}

		case 5: // Timeseries (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'timeseries' (tag=5), expected 2 (length-delimited)", wt)
			}
			var mm TimeSeries
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'timeseries' (tag=5): %w", err)
			}
			m.Timeseries = append(m.Timeseries, &mm)

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for TimeSeries

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *TimeSeries) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	//if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
	//	return csz
	//}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// LabelsRefs (uint32,repeated)
	for _, iv := range m.LabelsRefs {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(iv))
	}
	// Samples (message,repeated)
	for _, val := range m.Samples {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// Histograms (message,repeated)
	for _, val := range m.Histograms {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// Exemplars (message,repeated)
	for _, val := range m.Exemplars {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// Metadata (message,optional)
	if m.Metadata != nil {
		l = csproto.Size(m.Metadata)
		sz += csproto.SizeOfTagKey(5) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// CreatedTimestamp (int64,optional)
	//if m.CreatedTimestamp != 0 {
	sz += csproto.SizeOfTagKey(6) + csproto.SizeOfVarint(uint64(m.CreatedTimestamp))
	//}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	//atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *TimeSeries) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := bufPool.Get(siz)
	defer bufPool.Put(buf)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *TimeSeries) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// LabelsRefs (1,uint32,repeated)
	for _, val := range m.LabelsRefs {
		enc.EncodeUInt32(1, val)
	}
	// Samples (2,message,repeated)
	for _, mm := range m.Samples {
		if err = enc.EncodeNested(2, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'samples' (tag=2): %w", err)
		}
	}
	// Histograms (3,message,repeated)
	for _, mm := range m.Histograms {
		if err = enc.EncodeNested(3, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'histograms' (tag=3): %w", err)
		}
	}
	// Exemplars (4,message,repeated)
	for _, mm := range m.Exemplars {
		if err = enc.EncodeNested(4, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'exemplars' (tag=4): %w", err)
		}
	}
	// Metadata (5,message,optional)
	if m.Metadata != nil {
		if err = enc.EncodeNested(5, m.Metadata); err != nil {
			return fmt.Errorf("unable to encode message data for field 'metadata' (tag=5): %w", err)
		}
	}
	// CreatedTimestamp (6,int64,optional)
	//if m.CreatedTimestamp != 0 {
	enc.EncodeInt64(6, m.CreatedTimestamp)
	//}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *TimeSeries) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // LabelsRefs (uint32,repeated)
			switch wt {
			case csproto.WireTypeVarint:
				if v, err := dec.DecodeUInt32(); err != nil {
					return fmt.Errorf("unable to decode uint32 value for field 'labels_refs' (tag=1): %w", err)
				} else {
					m.LabelsRefs = append(m.LabelsRefs, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedUint32(); err != nil {
					return fmt.Errorf("unable to decode packed uint32 values for field 'labels_refs' (tag=1): %w", err)
				} else {
					m.LabelsRefs = append(m.LabelsRefs, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'labels_refs' (tag=1), expected 0 (varint) or 1 (length-delimited)", wt)
			}
		case 2: // Samples (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'samples' (tag=2), expected 2 (length-delimited)", wt)
			}
			var mm Sample
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'samples' (tag=2): %w", err)
			}
			m.Samples = append(m.Samples, &mm)
		case 3: // Histograms (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'histograms' (tag=3), expected 2 (length-delimited)", wt)
			}
			var mm Histogram
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'histograms' (tag=3): %w", err)
			}
			m.Histograms = append(m.Histograms, &mm)
		case 4: // Exemplars (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'exemplars' (tag=4), expected 2 (length-delimited)", wt)
			}
			var mm Exemplar
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'exemplars' (tag=4): %w", err)
			}
			m.Exemplars = append(m.Exemplars, &mm)
		case 5: // Metadata (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'metadata' (tag=5), expected 2 (length-delimited)", wt)
			}
			var mm Metadata
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'metadata' (tag=5): %w", err)
			}
			m.Metadata = &mm
		case 6: // CreatedTimestamp (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'created_timestamp' (tag=6), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'created_timestamp' (tag=6): %w", err)
			} else {
				m.CreatedTimestamp = v
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for Exemplar

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *Exemplar) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// LabelsRefs (uint32,repeated,packed)
	if len(m.LabelsRefs) > 0 {
		sz += csproto.SizeOfTagKey(1)
		l = 0
		for _, iv := range m.LabelsRefs {
			l += csproto.SizeOfVarint(uint64(iv))
		}
		sz += csproto.SizeOfVarint(uint64(l)) + l
	}
	// Value (double,optional)
	//if m.Value != 0 {
	sz += csproto.SizeOfTagKey(2) + 8
	//}
	// Timestamp (int64,optional)
	//if m.Timestamp != 0 {
	sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(m.Timestamp))
	//}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *Exemplar) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := bufPool.Get(siz)
	defer bufPool.Put(buf)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *Exemplar) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// LabelsRefs (1,uint32,repeated,packed)
	if len(m.LabelsRefs) > 0 {
		enc.EncodePackedUInt32(1, m.LabelsRefs)
	}
	// Value (2,double,optional)
	//if m.Value != 0 {
	enc.EncodeFloat64(2, m.Value)
	//}
	// Timestamp (3,int64,optional)
	//if m.Timestamp != 0 {
	enc.EncodeInt64(3, m.Timestamp)
	//}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *Exemplar) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // LabelsRefs (uint32,repeated,packed)
			switch wt {
			case csproto.WireTypeVarint:
				if v, err := dec.DecodeUInt32(); err != nil {
					return fmt.Errorf("unable to decode uint32 value for field 'labels_refs' (tag=1): %w", err)
				} else {
					m.LabelsRefs = append(m.LabelsRefs, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedUint32(); err != nil {
					return fmt.Errorf("unable to decode packed uint32 values for field 'labels_refs' (tag=1): %w", err)
				} else {
					m.LabelsRefs = append(m.LabelsRefs, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'labels_refs' (tag=1), expected 0 (varint) or 1 (length-delimited)", wt)
			}
		case 2: // Value (double,optional)
			if wt != csproto.WireTypeFixed64 {
				return fmt.Errorf("incorrect wire type %v for tag field 'value' (tag=2), expected 1 (64-bit)", wt)
			}
			if v, err := dec.DecodeFloat64(); err != nil {
				return fmt.Errorf("unable to decode double value for field 'value' (tag=2): %w", err)
			} else {
				m.Value = v
			}
		case 3: // Timestamp (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'timestamp' (tag=3), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'timestamp' (tag=3): %w", err)
			} else {
				m.Timestamp = v
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for Sample

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *Sample) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Value (double,optional)
	//if m.Value != 0 {
	sz += csproto.SizeOfTagKey(1) + 8
	//}
	// Timestamp (int64,optional)
	//if m.Timestamp != 0 {
	sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(m.Timestamp))
	//}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *Sample) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := bufPool.Get(siz)
	defer bufPool.Put(buf)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *Sample) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Value (1,double,optional)
	//if m.Value != 0 {
	enc.EncodeFloat64(1, m.Value)
	//}
	// Timestamp (2,int64,optional)
	//if m.Timestamp != 0 {
	enc.EncodeInt64(2, m.Timestamp)
	//}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *Sample) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Value (double,optional)
			if wt != csproto.WireTypeFixed64 {
				return fmt.Errorf("incorrect wire type %v for tag field 'value' (tag=1), expected 1 (64-bit)", wt)
			}
			if v, err := dec.DecodeFloat64(); err != nil {
				return fmt.Errorf("unable to decode double value for field 'value' (tag=1): %w", err)
			} else {
				m.Value = v
			}
		case 2: // Timestamp (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'timestamp' (tag=2), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'timestamp' (tag=2): %w", err)
			} else {
				m.Timestamp = v
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for Metadata

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *Metadata) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	//if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
	//	return csz
	//}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Type (enum,optional)
	//if m.Type != 0 {
	sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(m.Type))
	//}
	// HelpRef (uint32,optional)
	//if m.HelpRef != 0 {
	sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(m.HelpRef))
	//}
	// UnitRef (uint32,optional)
	//if m.UnitRef != 0 {
	sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(m.UnitRef))
	//}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	//atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *Metadata) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := bufPool.Get(siz)
	defer bufPool.Put(buf)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *Metadata) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Type (1,enum,optional)
	//if m.Type != 0 {
	enc.EncodeInt32(1, int32(m.Type))
	//}
	// HelpRef (3,uint32,optional)
	//if m.HelpRef != 0 {
	enc.EncodeUInt32(3, m.HelpRef)
	//}
	// UnitRef (4,uint32,optional)
	//if m.UnitRef != 0 {
	enc.EncodeUInt32(4, m.UnitRef)
	//}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *Metadata) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Type (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'type' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'type' (tag=1): %w", err)
			} else {
				m.Type = Metadata_MetricType(v)
			}
		case 3: // HelpRef (uint32,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'help_ref' (tag=3), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeUInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'help_ref' (tag=3): %w", err)
			} else {
				m.HelpRef = v
			}
		case 4: // UnitRef (uint32,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'unit_ref' (tag=4), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeUInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'unit_ref' (tag=4): %w", err)
			} else {
				m.UnitRef = v
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for Histogram

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *Histogram) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	//if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
	//	return csz
	//}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Sum (double,optional)
	//if m.Sum != 0 {
	sz += csproto.SizeOfTagKey(3) + 8
	//}
	// Schema (sint32,optional)
	//if m.Schema != 0 {
	sz += csproto.SizeOfTagKey(4) + csproto.SizeOfZigZag(uint64(m.Schema))
	//}
	// ZeroThreshold (double,optional)
	//if m.ZeroThreshold != 0 {
	sz += csproto.SizeOfTagKey(5) + 8
	//}
	// NegativeSpans (message,repeated)
	for _, val := range m.NegativeSpans {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(8) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// NegativeDeltas (sint64,repeated,packed)
	if len(m.NegativeDeltas) > 0 {
		sz += csproto.SizeOfTagKey(9)
		l = 0
		for _, iv := range m.NegativeDeltas {
			l += csproto.SizeOfZigZag(uint64(iv))
		}
		sz += csproto.SizeOfVarint(uint64(l)) + l
	}
	// NegativeCounts (double,repeated,packed)
	if l = len(m.NegativeCounts); l > 0 {
		sz += csproto.SizeOfTagKey(10) + csproto.SizeOfVarint(uint64(l)) + (l * 8)
	}
	// PositiveSpans (message,repeated)
	for _, val := range m.PositiveSpans {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(11) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// PositiveDeltas (sint64,repeated,packed)
	if len(m.PositiveDeltas) > 0 {
		sz += csproto.SizeOfTagKey(12)
		l = 0
		for _, iv := range m.PositiveDeltas {
			l += csproto.SizeOfZigZag(uint64(iv))
		}
		sz += csproto.SizeOfVarint(uint64(l)) + l
	}
	// PositiveCounts (double,repeated,packed)
	if l = len(m.PositiveCounts); l > 0 {
		sz += csproto.SizeOfTagKey(13) + csproto.SizeOfVarint(uint64(l)) + (l * 8)
	}
	// ResetHint (enum,optional)
	//if m.ResetHint != 0 {
	sz += csproto.SizeOfTagKey(14) + csproto.SizeOfVarint(uint64(m.ResetHint))
	//}
	// Timestamp (int64,optional)
	//if m.Timestamp != 0 {
	sz += csproto.SizeOfTagKey(15) + csproto.SizeOfVarint(uint64(m.Timestamp))
	//}
	// CustomValues (double,repeated,packed)
	if l = len(m.CustomValues); l > 0 {
		sz += csproto.SizeOfTagKey(16) + csproto.SizeOfVarint(uint64(l)) + (l * 8)
	}

	// Count (oneof)
	if m.Count != nil {
		switch typedVal := m.Count.(type) {
		case *Histogram_CountInt: // count_int (1,uint64)
			sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(typedVal.CountInt))
		case *Histogram_CountFloat: // count_float (2,double)
			sz += csproto.SizeOfTagKey(2) + 8
		default:
			_ = typedVal // ensure no unused variable
		}
	}

	// ZeroCount (oneof)
	if m.ZeroCount != nil {
		switch typedVal := m.ZeroCount.(type) {
		case *Histogram_ZeroCountInt: // zero_count_int (6,uint64)
			sz += csproto.SizeOfTagKey(6) + csproto.SizeOfVarint(uint64(typedVal.ZeroCountInt))
		case *Histogram_ZeroCountFloat: // zero_count_float (7,double)
			sz += csproto.SizeOfTagKey(7) + 8
		default:
			_ = typedVal // ensure no unused variable
		}
	}

	// cache the size so it can be re-used in Marshal()/MarshalTo()
	//atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *Histogram) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := bufPool.Get(siz)
	defer bufPool.Put(buf)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *Histogram) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Sum (3,double,optional)
	//if m.Sum != 0 {
	enc.EncodeFloat64(3, m.Sum)
	//}
	// Schema (4,sint32,optional)
	//if m.Schema != 0 {
	enc.EncodeSInt32(4, m.Schema)
	//}
	// ZeroThreshold (5,double,optional)
	//if m.ZeroThreshold != 0 {
	enc.EncodeFloat64(5, m.ZeroThreshold)
	//}
	// NegativeSpans (8,message,repeated)
	for _, mm := range m.NegativeSpans {
		if err = enc.EncodeNested(8, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'negative_spans' (tag=8): %w", err)
		}
	}
	// NegativeDeltas (9,sint64,repeated,packed)
	if len(m.NegativeDeltas) > 0 {
		enc.EncodePackedSInt64(9, m.NegativeDeltas)
	}
	// NegativeCounts (10,double,repeated,packed)
	if len(m.NegativeCounts) > 0 {
		enc.EncodePackedFloat64(10, m.NegativeCounts)
	}
	// PositiveSpans (11,message,repeated)
	for _, mm := range m.PositiveSpans {
		if err = enc.EncodeNested(11, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'positive_spans' (tag=11): %w", err)
		}
	}
	// PositiveDeltas (12,sint64,repeated,packed)
	if len(m.PositiveDeltas) > 0 {
		enc.EncodePackedSInt64(12, m.PositiveDeltas)
	}
	// PositiveCounts (13,double,repeated,packed)
	if len(m.PositiveCounts) > 0 {
		enc.EncodePackedFloat64(13, m.PositiveCounts)
	}
	// ResetHint (14,enum,optional)
	//if m.ResetHint != 0 {
	enc.EncodeInt32(14, int32(m.ResetHint))
	//}
	// Timestamp (15,int64,optional)
	//if m.Timestamp != 0 {
	enc.EncodeInt64(15, m.Timestamp)
	//}
	// CustomValues (16,double,repeated,packed)
	//if len(m.CustomValues) > 0 {
	enc.EncodePackedFloat64(16, m.CustomValues)
	//}
	// Count (oneof)

	if m.Count != nil {
		switch typedVal := m.Count.(type) {
		case *Histogram_CountInt: // count_int (1,uint64)
			enc.EncodeUInt64(1, typedVal.CountInt)
		case *Histogram_CountFloat: // count_float (2,double)
			enc.EncodeFloat64(2, typedVal.CountFloat)
		default:
			_ = typedVal // ensure no unused variable
		}
	}
	// ZeroCount (oneof)

	if m.ZeroCount != nil {
		switch typedVal := m.ZeroCount.(type) {
		case *Histogram_ZeroCountInt: // zero_count_int (6,uint64)
			enc.EncodeUInt64(6, typedVal.ZeroCountInt)
		case *Histogram_ZeroCountFloat: // zero_count_float (7,double)
			enc.EncodeFloat64(7, typedVal.ZeroCountFloat)
		default:
			_ = typedVal // ensure no unused variable
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *Histogram) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {

		case 3: // Sum (double,optional)
			if wt != csproto.WireTypeFixed64 {
				return fmt.Errorf("incorrect wire type %v for tag field 'sum' (tag=3), expected 1 (64-bit)", wt)
			}
			if v, err := dec.DecodeFloat64(); err != nil {
				return fmt.Errorf("unable to decode double value for field 'sum' (tag=3): %w", err)
			} else {
				m.Sum = v
			}
		case 4: // Schema (sint32,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'schema' (tag=4), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeSInt32(); err != nil {
				return fmt.Errorf("unable to decode sint32 value for field 'schema' (tag=4): %w", err)
			} else {
				m.Schema = v
			}
		case 5: // ZeroThreshold (double,optional)
			if wt != csproto.WireTypeFixed64 {
				return fmt.Errorf("incorrect wire type %v for tag field 'zero_threshold' (tag=5), expected 1 (64-bit)", wt)
			}
			if v, err := dec.DecodeFloat64(); err != nil {
				return fmt.Errorf("unable to decode double value for field 'zero_threshold' (tag=5): %w", err)
			} else {
				m.ZeroThreshold = v
			}

		case 8: // NegativeSpans (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'negative_spans' (tag=8), expected 2 (length-delimited)", wt)
			}
			var mm BucketSpan
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'negative_spans' (tag=8): %w", err)
			}
			m.NegativeSpans = append(m.NegativeSpans, &mm)
		case 9: // NegativeDeltas (sint64,repeated,packed)
			switch wt {
			case csproto.WireTypeVarint:
				if v, err := dec.DecodeSInt64(); err != nil {
					return fmt.Errorf("unable to decode sint64 value for field 'negative_deltas' (tag=9): %w", err)
				} else {
					m.NegativeDeltas = append(m.NegativeDeltas, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedSint64(); err != nil {
					return fmt.Errorf("unable to decode packed sint64 values for field 'negative_deltas' (tag=9): %w", err)
				} else {
					m.NegativeDeltas = append(m.NegativeDeltas, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'negative_deltas' (tag=9), expected 0 (varint) or 1 (length-delimited)", wt)
			}
		case 10: // NegativeCounts (double,repeated,packed)
			switch wt {
			case csproto.WireTypeFixed64:
				if v, err := dec.DecodeFloat64(); err != nil {
					return fmt.Errorf("unable to decode double value for field 'negative_counts' (tag=10): %w", err)
				} else {
					m.NegativeCounts = append(m.NegativeCounts, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedFloat64(); err != nil {
					return fmt.Errorf("unable to decode packed double values for field 'negative_counts' (tag=10): %w", err)
				} else {
					m.NegativeCounts = append(m.NegativeCounts, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'negative_counts' (tag=10), expected 1 (64-bit) or 1 (length-delimited)", wt)
			}
		case 11: // PositiveSpans (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'positive_spans' (tag=11), expected 2 (length-delimited)", wt)
			}
			var mm BucketSpan
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'positive_spans' (tag=11): %w", err)
			}
			m.PositiveSpans = append(m.PositiveSpans, &mm)
		case 12: // PositiveDeltas (sint64,repeated,packed)
			switch wt {
			case csproto.WireTypeVarint:
				if v, err := dec.DecodeSInt64(); err != nil {
					return fmt.Errorf("unable to decode sint64 value for field 'positive_deltas' (tag=12): %w", err)
				} else {
					m.PositiveDeltas = append(m.PositiveDeltas, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedSint64(); err != nil {
					return fmt.Errorf("unable to decode packed sint64 values for field 'positive_deltas' (tag=12): %w", err)
				} else {
					m.PositiveDeltas = append(m.PositiveDeltas, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'positive_deltas' (tag=12), expected 0 (varint) or 1 (length-delimited)", wt)
			}
		case 13: // PositiveCounts (double,repeated,packed)
			switch wt {
			case csproto.WireTypeFixed64:
				if v, err := dec.DecodeFloat64(); err != nil {
					return fmt.Errorf("unable to decode double value for field 'positive_counts' (tag=13): %w", err)
				} else {
					m.PositiveCounts = append(m.PositiveCounts, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedFloat64(); err != nil {
					return fmt.Errorf("unable to decode packed double values for field 'positive_counts' (tag=13): %w", err)
				} else {
					m.PositiveCounts = append(m.PositiveCounts, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'positive_counts' (tag=13), expected 1 (64-bit) or 1 (length-delimited)", wt)
			}
		case 14: // ResetHint (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'reset_hint' (tag=14), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'reset_hint' (tag=14): %w", err)
			} else {
				m.ResetHint = Histogram_ResetHint(v)
			}
		case 15: // Timestamp (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'timestamp' (tag=15), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'timestamp' (tag=15): %w", err)
			} else {
				m.Timestamp = v
			}
		case 16: // CustomValues (double,repeated,packed)
			switch wt {
			case csproto.WireTypeFixed64:
				if v, err := dec.DecodeFloat64(); err != nil {
					return fmt.Errorf("unable to decode double value for field 'custom_values' (tag=16): %w", err)
				} else {
					m.CustomValues = append(m.CustomValues, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedFloat64(); err != nil {
					return fmt.Errorf("unable to decode packed double values for field 'custom_values' (tag=16): %w", err)
				} else {
					m.CustomValues = append(m.CustomValues, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'custom_values' (tag=16), expected 1 (64-bit) or 1 (length-delimited)", wt)
			}

		case 1: // count.count_int (oneof,uint64)
			var ov Histogram_CountInt
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'count_int' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeUInt64(); err != nil {
				return fmt.Errorf("unable to decode uint64 value for field 'count_int' (tag=1): %w", err)
			} else {
				ov.CountInt = v
			}
			m.Count = &ov
		case 2: // count.count_float (oneof,double)
			var ov Histogram_CountFloat
			if wt != csproto.WireTypeFixed64 {
				return fmt.Errorf("incorrect wire type %v for tag field 'count_float' (tag=2), expected 1 (64-bit)", wt)
			}
			if v, err := dec.DecodeFloat64(); err != nil {
				return fmt.Errorf("unable to decode double value for field 'count_float' (tag=2): %w", err)
			} else {
				ov.CountFloat = v
			}
			m.Count = &ov
		case 6: // zero_count.zero_count_int (oneof,uint64)
			var ov Histogram_ZeroCountInt
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'zero_count_int' (tag=6), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeUInt64(); err != nil {
				return fmt.Errorf("unable to decode uint64 value for field 'zero_count_int' (tag=6): %w", err)
			} else {
				ov.ZeroCountInt = v
			}
			m.ZeroCount = &ov
		case 7: // zero_count.zero_count_float (oneof,double)
			var ov Histogram_ZeroCountFloat
			if wt != csproto.WireTypeFixed64 {
				return fmt.Errorf("incorrect wire type %v for tag field 'zero_count_float' (tag=7), expected 1 (64-bit)", wt)
			}
			if v, err := dec.DecodeFloat64(); err != nil {
				return fmt.Errorf("unable to decode double value for field 'zero_count_float' (tag=7): %w", err)
			} else {
				ov.ZeroCountFloat = v
			}
			m.ZeroCount = &ov
		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for BucketSpan

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *BucketSpan) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	//if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
	//	return csz
	//}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Offset (sint32,optional)
	//if m.Offset != 0 {
	sz += csproto.SizeOfTagKey(1) + csproto.SizeOfZigZag(uint64(m.Offset))
	//}
	// Length (uint32,optional)
	//if m.Length != 0 {
	sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(m.Length))
	//}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	//atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *BucketSpan) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := bufPool.Get(siz)
	defer bufPool.Put(buf)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *BucketSpan) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Offset (1,sint32,optional)
	//if m.Offset != 0 {
	enc.EncodeSInt32(1, m.Offset)
	//}
	// Length (2,uint32,optional)
	//if m.Length != 0 {
	enc.EncodeUInt32(2, m.Length)
	//}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *BucketSpan) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Offset (sint32,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'offset' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeSInt32(); err != nil {
				return fmt.Errorf("unable to decode sint32 value for field 'offset' (tag=1): %w", err)
			} else {
				m.Offset = v
			}
		case 2: // Length (uint32,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'length' (tag=2), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeUInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'length' (tag=2): %w", err)
			} else {
				m.Length = v
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}
